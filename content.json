{"meta":{"title":"( •̀ ω •́ )✧","subtitle":"","description":"","author":"方林","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-11-23T02:48:50.354Z","updated":"2020-11-23T02:48:50.354Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-11-23T02:45:23.927Z","updated":"2020-11-23T02:45:23.927Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2020-11-23T02:46:07.609Z","updated":"2020-11-23T02:46:07.609Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-23T03:18:48.319Z","updated":"2020-11-23T03:18:48.319Z","comments":true,"path":"js/click-love.js","permalink":"http://example.com/js/click-love.js","excerpt":"","text":"! function (e, t, a) { function n() { c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r() { for (var e = 0; e < d.length; e++) d[e].alpha"},{"title":"","date":"2020-11-23T02:47:31.636Z","updated":"2020-11-23T02:47:31.636Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-23T02:46:54.666Z","updated":"2020-11-23T02:46:54.666Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"LeetCode","date":"2020-11-30T07:58:58.580Z","updated":"2020-12-09T05:37:50.187Z","comments":true,"path":"2020/11/30/LeetCode/","link":"","permalink":"http://example.com/2020/11/30/LeetCode/","excerpt":"","text":"队列最近的请求次数题目描述：写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。保证 每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：[“RecentCounter”, “ping”, “ping”, “ping”, “ping”][[], [1], [100], [3001], [3002]]输出：[null, 1, 2, 3, 3] 解释：RecentCounter recentCounter = new RecentCounter();recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2recentCounter.ping(3001); // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3recentCounter.ping(3002); // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3 提示： 1 &lt;= t &lt;= 109保证每次对 ping 调用所使用的 t 值都 严格递增至多调用 ping 方法 104 次 解读：这题看了官方解析才知道什么意思。 题目有点脑筋急转弯的意思，你需要有一个记录请求的队列，队列里面的元素是每次输入的t，每次输入都会将t插入队列，并且将t和之前的t 作比较，统计并返回队列中的t在[t-3000,t]中的数 123456789101112131415161718192021public class RecentCounter &#123; Queue&lt;Integer&gt; queue; public RecentCounter()&#123; queue = new LinkedList&lt;&gt;(); &#125; /** * 首先加入队列，queue.add()，很好理解 * 然后查看队列第一个值是不是小于3000了，queue.peek() * 如果小于3000则移除改元素，因为题目中说t是递增的，所以不满足条件的可以直接删除 * 最后得到的队列就是符合条件的队列了，返回商长度即可 */ public int ping (int t)&#123; queue.add(t); while(queue.peek() &lt; t - 3000)&#123; queue.poll(); &#125; return queue.size(); &#125;&#125; 删除中间节点题目实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例： 输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c 结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f 解读这不是将链表头传进来，而是将要移动的节点传进来，我们需要写的是很基本的链表节点删除操作而已，由于题目指出节点不会是尾节点所以不用考虑越界问题 123456public class DeleteNodeInMiddle &#123; public void solution(ListNode node)&#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 链表解题套路 双指针 数据结构存储 递归 探针 指针遍历长度 快慢指针 二进制链表转整数题目解读正常题目容易理解，就是给你一个头节点，头节点装的是二进制数的第一个数 思路 按权展开，就是大家最常用的二进制转十进制的方法，用最后一位乘2^0，第二位乘2^1···以此类推得到结果 找到规律，遍历一遍就得到结果遍历一次链表就得到结果 难点： 思路1，链表倒序，按照倒序内容计算结果。思路1中提到的按权展开法，因为链表不能知道长度是多少，所以不知道每一位的权重是多少，所以需要把链表经过处理得到倒序的数值然后再一位一位计算。 思路2，找到规律使得能够通过一次遍历就得到结果 解法： 根据思路1，需要倒序链表，可以用链表，数组，整形，字符串，栈等数据结构接收，倒序完之后一位一位的相加。 思路2，发现只要将每次将之前的结果乘2再加上当前的值，计算结果，例如计算110的答案6，发现6是1*2^2+1*2^1+0*2^0，然后,2是1*2^1+0*2^0，0是1*2^0，我们要从第一个开始算，1是1，1*2^0，11是3，1*2^1+1*2^0，3是1*2+1，110是6，1*2^2+1*2^1+0*2^0，6是3*2+0 缺点： 解法一需要用到额外的空间，有可能很大，接收的数据结构如整形有长度限制等，并且遍历完之后还要再遍历计算，导致运行时间更长。 代码解法一1234567891011121314151617181920212223// 执行用时：2 ms, 在所有 Java 提交中击败了5.75%的用户// 内存消耗：35.9 MB, 在所有 Java 提交中击败了72.19%的用户// 解法1 栈，取出来放到栈里，然后再取出来计算public int getDecimalValue(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack(); ListNode current = head; int result = 0; int pow = 0; while(true)&#123; stack.push(current.val); current = current.next; if(current == null)&#123; break; &#125; &#125; while(!stack.empty())&#123; result = result + stack.pop() * (int)Math.pow(2,pow); pow++; &#125; return result;&#125; 解法二1234567891011121314// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.9 MB, 在所有 Java 提交中击败了74.62%的用户// 解法2 一次遍历得到结果，每次结果乘2加当前数public int getDecimalValue(ListNode head) &#123; ListNode current = head; int result = 0; while(current != null)&#123; // 乘2也可以用位运算操作，result &lt;&lt; 1 result = result * 2 + current.val; current = current.next; &#125; return result;&#125; 链表中倒数第k个节点题目解读容易理解，就是返回链表倒数第k个节点 思路： 将链表内容复制到可以计算长度的数据结构中，然后直接取size-k的值，返回 通过指针遍历一遍，获取长度，然后再遍历到size-k的节点，返回内容 探针，做一个离当前节点k位的指针，之后一起向后遍历，当探针为空时返回当前节点 代码思路1：将链表内容复制到可以计算长度的数据结构中，然后直接取size-k的值，返回 1234567891011// 执行用时: 1 ms// 内存消耗: 36.6 MBpublic ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode current = head; Stack&lt;ListNode&gt; stack = new Stack(); while(current != null)&#123; stack.push(current); current = current.next; &#125; return stack.get(stack.size() - k);&#125; 思路2：通过指针遍历一遍，获取长度，然后再遍历到size-k的节点，返回内容 123456789101112131415// 执行用时: 0 ms// 内存消耗: 36.3 MBpublic ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode counter = head; ListNode current = head; int size = 0; while(counter != null)&#123; size++; counter = counter.next; &#125; for(int i = 0; i &lt; size - k;i++)&#123; current = current.next; &#125; return current;&#125; 思路3：探针，做一个离当前节点k位的指针，之后一起向后遍历，当探针为空时返回当前节点 1234567891011121314// 执行用时：1 ms, 在所有 Java 提交中击败了13.51%的用户// 内存消耗：36.4 MB, 在所有 Java 提交中击败了66.70%的用户public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode scout = head; ListNode current = head; for(int i = 0; i &lt; k; i++)&#123; scout = scout.next; &#125; while(scout != null)&#123; current = current.next; scout = scout.next; &#125; return current;&#125; 返回倒数第 k 个节点题目解读容易理解，就是返回链表中倒数第几的数值 思路1：创造一个数组之类的数据结构逆序存储或顺序存储，之后用下标取出 思路2：用指针遍历一遍获取长度，然后再根据长度遍历到目标节点返回值 思路3：前探针，创造一个始终领先当前节点k位的系欸但，当同步向后遍历，当探针为空时，返回当前节点 思路4：递归，设置一个全局变量，每次递归加一，或者遍历到底后每次返回时加一 代码思路1：创造一个数组之类的数据结构逆序存储或顺序存储，之后用下标取出 1234567891011// 执行用时：1 ms, 在所有 Java 提交中击败了15.09%的用户// 内存消耗：36.2 MB, 在所有 Java 提交中击败了58.47%的用户public int kthToLast(ListNode head, int k) &#123; List&lt;Integer&gt; nodesValue = new ArrayList(); ListNode current = head; while(current != null)&#123; nodesValue.add(current.val); current = current.next; &#125; return nodesValue.remove(nodesValue.size() - k);&#125; 思路2：用指针遍历一遍获取长度，然后再根据长度遍历到目标节点返回值 123456789101112131415// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.8 MB, 在所有 Java 提交中击败了93.84%的用户public int kthToLast(ListNode head, int k) &#123; ListNode measurer = head; ListNode current = head; int length = 0; while(measurer != null)&#123; measurer = measurer.next; length++; &#125; for(int i = 0; i &lt; length - k; i++)&#123; current = current.next; &#125; return current.val;&#125; 思路3：前探针，创造一个始终领先当前节点k位的系欸但，当同步向后遍历，当探针为空时，返回当前节点 1234567891011121314// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.9 MB, 在所有 Java 提交中击败了86.66%的用户public int kthToLast(ListNode head, int k) &#123; ListNode scout = head; ListNode current = head; for(int i = 0; i &lt; k; i++)&#123; scout = scout.next; &#125; while(scout != null)&#123; scout = scout.next; current = current.next; &#125; return current.val;&#125; 思路4：递归，设置一个全局变量，每次递归加一，或者遍历到底后每次返回时加一，终止条件是链表为空，递归的过程中有且只有一次是对的，那么需要那次的返回值能够返回，所以最后的return value是必要的，使用value接收递归的结果也是必要的 12345678910111213141516171819// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.9 MB, 在所有 Java 提交中击败了86.66%的用户public int kthToLast(ListNode head, int k) &#123; ListNode node = head; return new Solution().reversePrint(node, k);&#125;int distance = 1;public int reversePrint(ListNode node, int k)&#123; if(node == null)&#123; return -1; &#125; int value = reversePrint(node.next, k); if(distance++ == k)&#123; return node.val; &#125; return value;&#125; 合并两个有序链表题目解读容易理解，就是把两个递增的链表整理成一个链表并且还是递增的 思路1： 暴力破解，使用一个节点当作头结点，将每次比较的结果一个个加进去 思路2： 递归，每次比较后将较小的节点的next指针进行递归，终止条件是l1或者l2为空的情况，返回l1或者l2 代码思路1：暴力破解，使用一个节点当作头结点，将每次比较的结果一个个加进去 1234567891011121314151617181920212223242526272829// 执行用时：1 ms, 在所有 Java 提交中击败了42.18%的用户// 内存消耗：37.6 MB, 在所有 Java 提交中击败了96.14%的用户public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(); ListNode current = head; while(l1 != null &amp;&amp; l2 != null)&#123; int value1 = l1.val; int value2 = l2.val; ListNode node = new ListNode(); if(value1 &gt; value2)&#123; node.val = value2; l2 = l2.next; &#125; else &#123; node.val = value1; l1 = l1.next; &#125; current.next = node; current = current.next; &#125; if(l1 != null)&#123; current.next = l1; &#125; if(l2 != null)&#123; current.next = l2; &#125; head = head.next; return head;&#125; 思路2：递归，每次比较后将较小的节点的next指针进行递归，终止条件是l1或者l2为空的情况，返回l1或者l2 123456789101112131415// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：37.9 MB, 在所有 Java 提交中击败了75.11%的用户public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; else if(l2 == null)&#123; return l1; &#125; else if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 从尾到头打印链表题目解读同理理解，就是把链表的内容逆序放在数组中返回 思路1：使用指针先遍历得到链表长度，然后逆序添加进数组 思路2：将内容取出来放入数据结构中，再一个一个取出 思路3：递归 代码思路1：使用指针先遍历得到链表长度，然后逆序添加进数组 123456789101112131415161718// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：39.2 MB 在所有 Java 提交中击败了62.03%的用户public int[] reversePrint(ListNode head) &#123; ListNode traversal = head; ListNode current = head; int length = 0; while(traversal != null)&#123; length++; traversal = traversal.next; &#125; int[] values = new int[length]; for(int i = length - 1;i &gt;= 0; i--)&#123; values[i] = current.val; current = current.next; &#125; return values;&#125; 思路2：将内容取出来放入数据结构中，再一个一个取出，此处用栈比较合适，注意遍历的时候不要用stack.size()因为值会变化，用values.length就行 123456789101112131415// 执行用时：2 ms, 在所有 Java 提交中击败了38.26%的用户// 内存消耗：39 MB, 在所有 Java 提交中击败了80.17%的用户public int[] reversePrint(ListNode head) &#123; ListNode current = head; Stack&lt;Integer&gt; stack = new Stack(); while(current != null)&#123; stack.push(current.val); current = current.next; &#125; int[] values = new int[stack.size()]; for(int i = 0; i &lt; values.length; i++)&#123; values[i] = stack.pop(); &#125; return values;&#125; 思路3：递归，递归到最后返回时添加进数组 123456789101112131415161718192021222324// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：39.8 MB, 在所有 Java 提交中击败了12.47%的用户public int[] reversePrint(ListNode head) &#123; ListNode traversal = head; int length = 0; while(traversal != null)&#123; length++; traversal = traversal.next; &#125; Solution solution = new Solution(); ListNode current = head; int[] values = new int[length]; solution.recursion(current,values.length - 1,values); return values;&#125;public void recursion(ListNode node,int index,int[] values)&#123; if(node == null)&#123; return; &#125; recursion(node.next, index-1, values); values[index] = node.val; return;&#125; 反转链表题目解读容易理解，就是反转链表 思路1：维护一个始终指向头节点的指针，遍历时将当前节点指向头节点 思路2：双指针，和方法1类似 思路3：递归 代码思路1：边走边换，将当前节点插入到第一个节点 123456789101112131415161718// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：38.5 MB, 在所有 Java 提交中击败了42.99%的用户public ListNode reverseList(ListNode head) &#123; if(head == null)&#123; return head; &#125; ListNode alwaysHead = head; ListNode current = head; while(current.next != null)&#123; ListNode after = current.next; current.next = after.next; after.next = alwaysHead; alwaysHead = after; after = current.next; &#125; return alwaysHead;&#125; 思路2：双指针，注意最后返回的是previous因为循环做完后current指向的是空指针 1234567891011121314// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：38.2 MB, 在所有 Java 提交中击败了81.55%的用户public ListNode reverseList(ListNode head) &#123; ListNode current = head; ListNode previous = null; ListNode after = null; while(current != null)&#123; after = current.next; current.next = previous; previous = current; current = after; &#125; return previous;&#125; 思路3：递归 1234567891011// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：38.6 MB, 在所有 Java 提交中击败了28.69%的用户public ListNode reverseList(ListNode head) &#123; if(head==null || head.next==null) &#123; return head; &#125; ListNode cur = reverseList(head.next); head.next.next = head; head.next = null; return cur;&#125; 链表的中间结点题目解读容易理解，就是返回链表的中间节点，当中介节点不止一个时取右边的节点 思路1：存储到数据结构中，然后根据下标取出 思路2：指针遍历得到长度，然后遍历到目标节点取出 思路3：快慢指针，慢节点每次走一步，快节点每次走两步 思路4：递归，定义全局变量length，每次递归加一并且记录当前节点的位置，递归返回时判断当前节点是否是中间节点 代码思路1：存储到数据结构中，这里用栈但是用数组更方便，再根据长度返回目标节点，根据题意要返回中间节点的靠右的节点，4 / 2 = 2, 5 / 2 = 2,这两个数的中间节点位置都是2，但是5应该返回3，所以将4和5都加1，各自除2就得到2和3 1234567891011121314151617// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.5 MB, 在所有 Java 提交中击败了84.64%的用户public ListNode middleNode(ListNode head) &#123; ListNode current = head; ListNode midle = head; Stack&lt;ListNode&gt; stack = new Stack(); while(current != null)&#123; stack.push(current); current = current.next; &#125; int length = stack.size() + 1; for(int i = 0; i &lt; length / 2; i++)&#123; midle = stack.pop(); &#125; return midle; &#125; 思路2：指针遍历得到长度，然后遍历到目标节点取出 1234567891011// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.8 MB, 在所有 Java 提交中击败了52.18%的用户public ListNode middleNode(ListNode head) &#123; ListNode traversal = head; ListNode current = head; int length = 0; while(traversal != null)&#123; length++; traversal = traversal.next; &#125;&#125; 思路3：快慢指针，慢节点每次走一步，快节点每次走两步 1234567891011// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.6 MB, 在所有 Java 提交中击败了80.68%的用户public ListNode middleNode(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125; 思路4：递归，定义全局变量length，每次递归加一并且记录当前节点的位置，递归返回时判断当前节点是否是中间节点 12345678910111213141516171819202122232425// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户// 内存消耗：35.9 MB, 在所有 Java 提交中击败了39.27%的用户public ListNode middleNode(ListNode head) &#123; ListNode current = head; return recursion(current);&#125;int length;public ListNode recursion(ListNode node)&#123; if(node == null)&#123; return null; &#125; length++; int current = length; ListNode result = recursion(node.next); if(result != null)&#123; return result; &#125; if(current - 1 == (length / 2))&#123; return node; &#125; else &#123; return null; &#125;&#125;","categories":[],"tags":[]},{"title":"article title","slug":"article-title","date":"2020-11-20T07:08:11.000Z","updated":"2020-11-20T07:08:11.679Z","comments":true,"path":"2020/11/20/article-title/","link":"","permalink":"http://example.com/2020/11/20/article-title/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-11-20T06:59:21.009Z","updated":"2020-11-20T06:59:21.009Z","comments":true,"path":"2020/11/20/hello-world/","link":"","permalink":"http://example.com/2020/11/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}