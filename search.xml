<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2020/11/30/LeetCode/"/>
      <url>2020/11/30/LeetCode/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="最近的请求次数"><a href="#最近的请求次数" class="headerlink" title="最近的请求次数"></a>最近的请求次数</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p><p>请你实现 RecentCounter 类：</p><p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p><p>示例：</p><p>输入：<br>[“RecentCounter”, “ping”, “ping”, “ping”, “ping”]<br>[[], [1], [100], [3001], [3002]]<br>输出：<br>[null, 1, 2, 3, 3]</p><p>解释：<br>RecentCounter recentCounter = new RecentCounter();<br>recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1<br>recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2<br>recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3<br>recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</p><p>提示：</p><p>1 &lt;= t &lt;= 109<br>保证每次对 ping 调用所使用的 t 值都 严格递增<br>至多调用 ping 方法 104 次</p><h4 id="解读："><a href="#解读：" class="headerlink" title="解读："></a>解读：</h4><p>这题看了<a href="https://leetcode-cn.com/problems/number-of-recent-calls/solution/zui-jin-de-qing-qiu-ci-shu-by-leetcode/">官方解析</a>才知道什么意思。</p><p>题目有点脑筋急转弯的意思，你需要有一个记录请求的队列，队列里面的元素是每次输入的t，每次输入都会将t插入队列，并且将t和之前的t 作比较，统计并返回队列中的t在[t-3000,t]中的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先加入队列，queue.add()，很好理解</span></span><br><span class="line"><span class="comment">     * 然后查看队列第一个值是不是小于3000了，queue.peek()</span></span><br><span class="line"><span class="comment">     * 如果小于3000则移除改元素，因为题目中说t是递增的，所以不满足条件的可以直接删除</span></span><br><span class="line"><span class="comment">     * 最后得到的队列就是符合条件的队列了，返回商长度即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span> <span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        queue.add(t);</span><br><span class="line">        <span class="keyword">while</span>(queue.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除中间节点"><a href="#删除中间节点" class="headerlink" title="删除中间节点"></a>删除中间节点</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p><ul><li>示例：</li><li>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</li><li>结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</li><li></li></ul><h4 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h4><p>这不是将链表头传进来，而是将要移动的节点传进来，我们需要写的是很基本的链表节点删除操作而已，由于题目指出节点不会是尾节点所以不用考虑越界问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNodeInMiddle</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">            node.val = node.next.val;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="解题套路"><a href="#解题套路" class="headerlink" title="解题套路"></a>解题套路</h3><ol><li>双指针</li><li>数据结构存储</li><li>递归</li><li>探针</li><li> 指针遍历长度</li><li>快慢指针</li></ol><h3 id="二进制链表转整数"><a href="#二进制链表转整数" class="headerlink" title="二进制链表转整数"></a><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">二进制链表转整数</a></h3><h4 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h4><p>正常题目容易理解，就是给你一个头节点，头节点装的是二进制数的第一个数</p><p>思路</p><ol><li>按权展开，就是大家最常用的二进制转十进制的方法，用最后一位乘2^0，第二位乘2^1···以此类推得到结果</li><li>找到规律，遍历一遍就得到结果遍历一次链表就得到结果</li></ol><p>难点：</p><ol><li>思路1，链表倒序，按照倒序内容计算结果。思路1中提到的按权展开法，因为链表不能知道长度是多少，所以不知道每一位的权重是多少，所以需要把链表经过处理得到倒序的数值然后再一位一位计算。</li><li>思路2，找到规律使得能够通过一次遍历就得到结果</li></ol><p>解法：</p><ol><li>根据思路1，需要倒序链表，可以用链表，数组，整形，字符串，栈等数据结构接收，倒序完之后一位一位的相加。</li><li>思路2，发现只要将每次将之前的结果乘2再加上当前的值，计算结果，例如计算110的答案6，发现6是1*2^2+1*2^1+0*2^0，然后,2是1*2^1+0*2^0，0是1*2^0，我们要从第一个开始算，1是1，1*2^0，11是3，1*2^1+1*2^0，3是1*2+1，110是6，1*2^2+1*2^1+0*2^0，6是3*2+0</li></ol><p>缺点：</p><ol><li>解法一需要用到额外的空间，有可能很大，接收的数据结构如整形有长度限制等，并且遍历完之后还要再遍历计算，导致运行时间更长。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：2 ms, 在所有 Java 提交中击败了5.75%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.9 MB, 在所有 Java 提交中击败了72.19%的用户</span></span><br><span class="line"><span class="comment">// 解法1 栈，取出来放到栈里，然后再取出来计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         stack.push(current.val);</span><br><span class="line">         current = current.next;</span><br><span class="line">         <span class="keyword">if</span>(current == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">         result = result + stack.pop() * (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,pow);</span><br><span class="line">         pow++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.9 MB, 在所有 Java 提交中击败了74.62%的用户</span></span><br><span class="line"><span class="comment">// 解法2 一次遍历得到结果，每次结果乘2加当前数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode current = head;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 乘2也可以用位运算操作，result &lt;&lt; 1 </span></span><br><span class="line">        result = result * <span class="number">2</span> + current.val;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></h3><h4 id="题目解读-1"><a href="#题目解读-1" class="headerlink" title="题目解读"></a>题目解读</h4><p>容易理解，就是返回链表倒数第k个节点</p><p>思路：</p><ol><li>将链表内容复制到可以计算长度的数据结构中，然后直接取size-k的值，返回</li><li>通过指针遍历一遍，获取长度，然后再遍历到size-k的节点，返回内容</li><li>探针，做一个离当前节点k位的指针，之后一起向后遍历，当探针为空时返回当前节点</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>思路1：将链表内容复制到可以计算长度的数据结构中，然后直接取size-k的值，返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36.6 MB</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size() - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：通过指针遍历一遍，获取长度，然后再遍历到size-k的节点，返回内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36.3 MB</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode counter = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(counter != <span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            counter = counter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - k;i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路3：探针，做一个离当前节点k位的指针，之后一起向后遍历，当探针为空时返回当前节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：1 ms, 在所有 Java 提交中击败了13.51%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：36.4 MB, 在所有 Java 提交中击败了66.70%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode scout = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            scout = scout.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(scout != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            scout = scout.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回倒数第-k-个节点"><a href="#返回倒数第-k-个节点" class="headerlink" title="返回倒数第 k 个节点"></a><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/">返回倒数第 k 个节点</a></h3><h4 id="题目解读-2"><a href="#题目解读-2" class="headerlink" title="题目解读"></a>题目解读</h4><p>容易理解，就是返回链表中倒数第几的数值</p><p>思路1：创造一个数组之类的数据结构逆序存储或顺序存储，之后用下标取出</p><p>思路2：用指针遍历一遍获取长度，然后再根据长度遍历到目标节点返回值</p><p>思路3：前探针，创造一个始终领先当前节点k位的系欸但，当同步向后遍历，当探针为空时，返回当前节点</p><p>思路4：递归，设置一个全局变量，每次递归加一，或者遍历到底后每次返回时加一</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>思路1：创造一个数组之类的数据结构逆序存储或顺序存储，之后用下标取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：1 ms, 在所有 Java 提交中击败了15.09%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：36.2 MB, 在所有 Java 提交中击败了58.47%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nodesValue = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nodesValue.add(current.val);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> nodesValue.remove(nodesValue.size() - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：用指针遍历一遍获取长度，然后再根据长度遍历到目标节点返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.8 MB, 在所有 Java 提交中击败了93.84%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode measurer = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(measurer != <span class="keyword">null</span>)&#123;</span><br><span class="line">            measurer = measurer.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - k; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路3：前探针，创造一个始终领先当前节点k位的系欸但，当同步向后遍历，当探针为空时，返回当前节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.9 MB, 在所有 Java 提交中击败了86.66%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode scout = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            scout = scout.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(scout != <span class="keyword">null</span>)&#123;</span><br><span class="line">            scout = scout.next;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路4：递归，设置一个全局变量，每次递归加一，或者遍历到底后每次返回时加一，终止条件是链表为空，递归的过程中有且只有一次是对的，那么需要那次的返回值能够返回，所以最后的return value是必要的，使用value接收递归的结果也是必要的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.9 MB, 在所有 Java 提交中击败了86.66%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> ListNode node = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Solution().reversePrint(node, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> distance = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePrint</span><span class="params">(ListNode node, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = reversePrint(node.next, k);</span><br><span class="line">        <span class="keyword">if</span>(distance++ == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h3><h4 id="题目解读-3"><a href="#题目解读-3" class="headerlink" title="题目解读"></a>题目解读</h4><p>容易理解，就是把两个递增的链表整理成一个链表并且还是递增的</p><p>思路1： 暴力破解，使用一个节点当作头结点，将每次比较的结果一个个加进去</p><p>思路2： 递归，每次比较后将较小的节点的next指针进行递归，终止条件是l1或者l2为空的情况，返回l1或者l2</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>思路1：暴力破解，使用一个节点当作头结点，将每次比较的结果一个个加进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：1 ms, 在所有 Java 提交中击败了42.18%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：37.6 MB, 在所有 Java 提交中击败了96.14%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = l1.val;</span><br><span class="line">            <span class="keyword">int</span> value2 = l2.val;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode();</span><br><span class="line">            <span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line">                node.val = value2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.val = value1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：递归，每次比较后将较小的节点的next指针进行递归，终止条件是l1或者l2为空的情况，返回l1或者l2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：37.9 MB, 在所有 Java 提交中击败了75.11%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h3><h4 id="题目解读-4"><a href="#题目解读-4" class="headerlink" title="题目解读"></a>题目解读</h4><p>同理理解，就是把链表的内容逆序放在数组中返回</p><p>思路1：使用指针先遍历得到链表长度，然后逆序添加进数组</p><p>思路2：将内容取出来放入数据结构中，再一个一个取出</p><p>思路3：递归</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>思路1：使用指针先遍历得到链表长度，然后逆序添加进数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：39.2 MB 在所有 Java 提交中击败了62.03%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        ListNode traversal = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">int</span> length =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(traversal != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            traversal = traversal.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            values[i] = current.val;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：将内容取出来放入数据结构中，再一个一个取出，此处用栈比较合适，注意遍历的时候不要用stack.size()因为值会变化，用values.length就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：2 ms, 在所有 Java 提交中击败了38.26%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：39 MB, 在所有 Java 提交中击败了80.17%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(current.val);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">            values[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路3：递归，递归到最后返回时添加进数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：39.8 MB, 在所有 Java 提交中击败了12.47%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        ListNode traversal = head;</span><br><span class="line">        <span class="keyword">int</span> length =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(traversal != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            traversal = traversal.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        solution.recursion(current,values.length - <span class="number">1</span>,values);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(ListNode node,<span class="keyword">int</span> index,<span class="keyword">int</span>[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recursion(node.next, index-<span class="number">1</span>, values);</span><br><span class="line">        values[index] = node.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h3><h4 id="题目解读-5"><a href="#题目解读-5" class="headerlink" title="题目解读"></a>题目解读</h4><p>容易理解，就是反转链表</p><p>思路1：维护一个始终指向头节点的指针，遍历时将当前节点指向头节点</p><p>思路2：双指针，和方法1类似</p><p>思路3：递归</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>思路1：边走边换，将当前节点插入到第一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：38.5 MB, 在所有 Java 提交中击败了42.99%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode alwaysHead = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(current.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode after = current.next;</span><br><span class="line">            current.next = after.next;</span><br><span class="line">            after.next = alwaysHead;</span><br><span class="line">            alwaysHead = after;</span><br><span class="line">            after = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alwaysHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：双指针，注意最后返回的是previous因为循环做完后current指向的是空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：38.2 MB, 在所有 Java 提交中击败了81.55%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode current = head;</span><br><span class="line">        ListNode previous = <span class="keyword">null</span>;</span><br><span class="line">        ListNode after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            after = current.next;</span><br><span class="line">            current.next = previous;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = after;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路3：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：38.6 MB, 在所有 Java 提交中击败了28.69%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">ListNode cur = reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">链表的中间结点</a></h3><h4 id="题目解读-6"><a href="#题目解读-6" class="headerlink" title="题目解读"></a>题目解读</h4><p>容易理解，就是返回链表的中间节点，当中介节点不止一个时取右边的节点</p><p>思路1：存储到数据结构中，然后根据下标取出</p><p>思路2：指针遍历得到长度，然后遍历到目标节点取出</p><p>思路3：快慢指针，慢节点每次走一步，快节点每次走两步</p><p>思路4：递归，定义全局变量length，每次递归加一并且记录当前节点的位置，递归返回时判断当前节点是否是中间节点</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><p>思路1：存储到数据结构中，这里用栈但是用数组更方便，再根据长度返回目标节点，根据题意要返回中间节点的靠右的节点，4 / 2 = 2, 5 / 2 = 2,这两个数的中间节点位置都是2，但是5应该返回3，所以将4和5都加1，各自除2就得到2和3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.5 MB, 在所有 Java 提交中击败了84.64%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        ListNode midle = head; </span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = stack.size() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            midle = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> midle;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路2：指针遍历得到长度，然后遍历到目标节点取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.8 MB, 在所有 Java 提交中击败了52.18%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode traversal = head;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(traversal != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            traversal = traversal.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路3：快慢指针，慢节点每次走一步，快节点每次走两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.6 MB, 在所有 Java 提交中击败了80.68%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路4：递归，定义全局变量length，每次递归加一并且记录当前节点的位置，递归返回时判断当前节点是否是中间节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：35.9 MB, 在所有 Java 提交中击败了39.27%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode current = head;</span><br><span class="line">        <span class="keyword">return</span>  recursion(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">recursion</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">int</span> current = length;</span><br><span class="line">        ListNode result = recursion(node.next);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current - <span class="number">1</span> == (length / <span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">链表相交</a></h3><h4 id="题目解读-7"><a href="#题目解读-7" class="headerlink" title="题目解读"></a>题目解读</h4><p> 有点小陷阱，注意题目让我们找的是节点ListNode，不是值val，另外注意既然是相同节点，那么这两个链表自相同节点之后都是相同的节点，这个可作为解题的一个突破口</p><p>思路1：set存储节点，之后遍历放入直到遇到重复节点返回</p><p>思路2：双指针法1</p><p>思路:3：双指针法2</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><p>思路1：set存储节点，之后遍历放入直到遇到重复节点返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：10 ms, 在所有 Java 提交中击败了10.40%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：42 MB, 在所有 Java 提交中击败了8.92%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="keyword">null</span> &amp;&amp; headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(headA))&#123;</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!set.add(headB))&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(headA))&#123;</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            &#125;</span><br><span class="line">             headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(headB))&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">             headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/dai-ma-jie-shi-shuang-zhi-zhen-suan-fa-wei-shi-yao/">思路2</a>：双指针法1，AB同时向后移动，当A或B为null时将A置为B，B置为A，这时候会发现两个链表的长度相同了，因为相对来说长的链表向后移动了|lenA-lenB|的长度,并且如果链表中没有相同元素的话他们会都为null，以这个为终止条件就可以防止无限循环了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：41.2 MB, 在所有 Java 提交中击败了68.83%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">     ListNode a = headA;</span><br><span class="line">     ListNode b = headB;</span><br><span class="line">     <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">         <span class="keyword">if</span>(a != <span class="keyword">null</span>)&#123;</span><br><span class="line">             a = a.next;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             a = headB;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(b != <span class="keyword">null</span>)&#123;</span><br><span class="line">             b = b.next;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             b = headA;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/ji-he-shuang-zhi-zhen-deng-3chong-jie-jue-fang-s-3/">思路3</a>：遍历获取各自链表长度，然后让长的移动|lenA-lenB|的位后一起遍历比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗：41.1 MB, 在所有 Java 提交中击败了85.90%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">    ListNode a = headA;</span><br><span class="line">    ListNode b = headB; </span><br><span class="line">    <span class="keyword">while</span>(a != <span class="keyword">null</span>)&#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        a = a.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="keyword">null</span>)&#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode longer ;</span><br><span class="line">    ListNode shortr ;</span><br><span class="line">    <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line">        longer = headB;</span><br><span class="line">        shortr = headA;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lenB - lenA; i++)&#123;</span><br><span class="line">            longer = longer.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        longer = headA;</span><br><span class="line">        shortr = headB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lenA - lenB; i++)&#123;</span><br><span class="line">            longer = longer.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(longer != shortr)&#123;</span><br><span class="line">        longer = longer.next;</span><br><span class="line">        shortr = shortr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shortr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="2020/11/20/article-title/"/>
      <url>2020/11/20/article-title/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/20/hello-world/"/>
      <url>2020/11/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
